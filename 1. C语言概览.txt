1. 第一个程序
#include <stdio.h>

int main(){
    printf("hello");
    return 0;
}
- main() 意思为主函数
    主函数是函数的入口，写任何c语言的代码都必须要有main()函数
    main()函数有，且只有一个
- int是整型的意思，main()前面的int表示表示main()调用返回一个整型值，如后面的: return 0;
- 在屏幕上输出内容，我们可以用printf();来解决
- 如printf()这种的，统称为库函数，即c语言本身提供给我们的函数，通俗来讲就是别人的东西
- 用别人的东西我们肯定需要打招呼呀，所以前面的#include <stdio.h>就是打招呼的作用
    #include这是包含的意思，包含一个叫做stdio.h的文件
    std -> 即标准，全称standard input output -> 即标准输入输出

2. 初识数据类型
Char		//字符串数据类型
Short		//短整型
Int			//整型
Long		//长整型
Long long	//更长的整型
Float		//单精度浮点型
Double	    //双精度浮点型
- 如果要在程序中创建一个数据，需要前面加上数据类型，如：char ch='a';  //创建字符串‘a’
- 打印输出的时候需要格式化字符串，对应关系如下：
    整型 -> %d
    字符串 -> %c
    浮点数 -> %f
    双精度浮点数 -> %lf
    以地址的形式打印 -> %p
    打印十进制数 -> %x
    打印八进制数 -> %o
    ...
- 同时，我们要是想知道各种数据类型占据的字节数，我们可以使用sizeof()来获取，括号内填数据类型
    # 我们在写程序的时候，应该视情况而定义数据类型，不同类型占用的内存不同，如果有太多内存用不到，就会造成浪费
    # 通过1字节等于8比特，且short占用2字节，有2*8=16可得出占用16比特，再2^16-1=65535，所以short占用65535个比特位，可以输入65535个数字，其他类型计算方法同理
- 我们在写入float数据类型的时候，如果想明确表示一个数是单精度浮点型，可以在数值后面加f，如：float a = 15.6f;

3. 变量
定义方法：
char ch = 'w';
int num = 15;
float f = 15.6f;
//在变量前面加上它的数据类型名称
- 全局变量
    定义在代码块'{}'外的变量即全局变量，同时以为这可以在全局范围内进行访问，使用范围大
- 局部变量
    定义在代码块'{}'内的变量即局部变量，使用范围小
    - 当局部变量和全局变量名字相同的时候局部变量优先
        局部变量和全局变量的名字建议不要相同，不然容易引起bug
    - 如果我们要输入数据，使用输入数据函数scanf，后面需要有取地址符号'&'，如：scanf("%d%d",&num1,&num2);
        c语言编译器较新的可能会使用scanf_s来输入数据
        或者我们可以在：项目->属性->配置属性->C/C++ -> 预处理器 -> 预处理器定义，增加：_CRT_SECURE_NO_DEPRECATE， 这样也可以正常运行程序
        #之后我们就可以在程序运行时，来输入num1和num2的数据了
    - c语言中有个特殊的语法规定，变量要定义在当前代码块的最前面，不然可能会报错！
- 变量的作用域和生命周期：
    作用域：
        程序设计概念，通常来说，一段程序代码中所用到的名字并不是总是有效/可用的，而限定这个名字的可用性代码范围就是作用域
        如：
            int main(){                                             int main(){
                int num = 10;                                              {int num = 10;}
                printf("num = %d", num); //此时num就在作用域内               printf("num = %d", num); //此时num不在作用域内
            }                                                       }
            #这段代码哪里能用，哪里就是他的作用域！
    1.局部变量的作用域是变量所在的局部范围
    2.全局变量的作用域时整个工程
        整个工程不单单指当前文件噢~我们可以访问当前工程内任意文件的全局变量，只不过要在文件内先声明
		全局变量不如只声明不初始化变量值，默认为0
        使用extern来声明，后面加上变量的数据类型，如：extern int num;
			extern还可以用来声明其他源文件中的函数，如：extern Add(int,int);
    生命周期：
        变量的生命周期是指变量的创建到变量的销毁之间的一个时间段
        1.局部变量的生命周期：进入作用域生命周期开始，出作用域生命周期结束
        2.全局变量的生命周期：整个程序的生命周期

4. 不安全函数
上面我们讲到了scanf()函数使用会报错，这是因为这是一个不安全函数
相同的还有：
strcpy
strcat
sscanf
fopen
...

5. 常量
那些不变的量就称为常量，c语言的常量分为以下几种：
- 字面常量  
- const 修饰的常变量
- #define定义的标识符常量
- 枚举常量

字面常量：直接就写出来的，如：3;
常变量：用const修饰的就叫常变量，如：const num=8; 这样定义之后，num就不能再修改了，如果修改就会报错
标识符常量：用#define定义的就是标识符常量，如：#define MAX 10  这样就定义了一个名称为MAX值为10的常量，和常变量不同的是它可以直接放到只允许放置常量的函数中去
枚举常量：枚举——一一列举，如生活中的性别：男/女/保密，星期：1-7...
我们在c语言中定义枚举常量用以下方法：
enum 名字{
    列举的值
    ...
};  //这里的';'不能少
实例：
enum sex {
	man,
	wuman,  //如果在main()函数中打印出这三个常量，返回的是0/1/2
	secret
};          //可以用enum sex sex = man; 获取它的值，这里定义的sex是可以改的，只有枚举常量里面的值是不能改的，如：woman=20;  这就会报错

6. 字符串/转译字符/注释
字符串：
    - char表示的是字符类型，不是字符串类型噢~
        不过我们可以通过一些方法来让char定义字符串，如使用数值：char str[] = "abc";
        但是如果这样，如：char str2[] = {'a','b','c'},就会报错
        为什么呢，因为第一中方法定义的字符串其实后面还有写'\0'没显示，而如果第二种方法要正确显示就要在最后面加上0或'\0'
            这里的'\0'是字符串的结束标志，如果没有这个结束标志，就会接着往后打印一些随机值
            我们可以用strlen来读取字符串长度
转译字符：
在一些字母前面加'\'改变它原来的意思
常用的有：
\n      换行
\t      水平制表符(tab)
\\      但斜杠
\ddd    ddd表示1-3个八进制的数字，如：\130 X
\xdd    dd表示2个十六进制数字，如：\X30 0
...
可看python书本P57页，一模一样
strlen读取转义字符时，一个转译字符和后面的字母算一位，如：strlen("c:\test\32\test.c")，一共有13个字符，\t和\32都算1字符

注释：
- 单行注释使用( // )
- 多行注释使用( /* 内容... */ )，缺陷：不支持嵌套
- 注释快捷键(VS2019)：
		添加 -> Ctrl+k+c
		取消 -> Ctrl+k+u

7. 选择语句和循环语句
- 选择语句语法：
	if(条件表达式){		//条件表达式为true时执行
			语句1....
	}
	else{		//为false时执行
			语句2...
	}

- 循环语句
	c语言中有三种循环：
		1. while循环
		2. for循环
		3. do...while循环
	while循环语法：
	while(条件表达式){		//条件表达式为true时会一直执行下面的语句直到为false
			语句1...
			语句2...(改变条件表达式的值)
	}
	for循环语法：
	do...while循环语法：
	
8. 函数
- 库函数
	如前面所学习的printf(); scanf().....
- 自定义函数
	创建函数语法：
		数据类型 函数名(形参1,形参2){
				语句...
		}
	实例：int sum(a,b){
			return a+b;
	}

9. 数组
要存储1-10的数字，怎么存储？
c语言中给了数组的定义：一种相同类型元素的集合
创建数组：
	int num[10] = {1,2,3,4,5,6,7,8,9,10};		//这里的int表示创建数组的数据类型，也可以是char或者别的数据类型
				//这里的[10]代表着可以存放10个元素
	- 数组中每一个数都有索引值，索引值是从左往右，从0开始数的
	- 例子中数组前面的int不是代表数组的类型，而是数组里面元素的值的类型，所以我们用sizeof(num)的时候，应该是int的4字节*10个元素 = 40字节
	- 如果我们要计算出数组中的元素个数，可以使用sizeof(num) / sizeof(num[0])来计算
	
10. 操作符
- 算数操作符
	+	-	*	/	%
- 移位操作符
	>>	<<
	如：
		short num = 1;
		int num2 = num << 1;		
		这里移动的是二进制位，可知short占2字节就是16个bit，那么num转换成二进制就是00000000 00000001
																						左移一位就是0 00000000 00000010，最前面的0取掉，最后面补一个0，二进制转十进制可得结果为2
		printf("%d" , num2);		这里打印的结果就是2，右移同理
- 位操作符
	&与   |或   ^异或
	用位操作符进行运算的时候，都要先把十进制数转换成二进制数在进行运算
	与运算	如：3&5	3的十进制是011，5的十进制是101，运算的时候，只有两边都为1结果才为1，所以011&101的结果是001，再转换会十进制就是1，即3&5 == 1；
	或运算	如：3|5		二进制数和上面相同，但是或运算只要有一个结果是1，就会返回1，所以011|101的结果是111，再转换成十进制就是7，即3|5==7；
	异或运算	^在这里代表的不是次方，而是异或运算符，运算规律：对应的二进制位相同则为0，对应的二进制位互异则为1
				如：3^5	二进制还是011和101，一一对应后110，再转换会十进制就是6，即3&5==6；
- 赋值操作符
	=  +=  -=  *=  /=  &=  |=  ^=  >>=  <<=
- 单目操作符
	！逻辑反操作		+	-	&	 sizeof  ~  --  ++  *  (类型)
	'!'差不多可以理解为非运算符，!1==0;  !0==1;	大于1同样视为1来运算
	'sizeof'返回的是数据类型的长度，而不是字符的长度，字符的长度用strlen查询
		但是如果sizeof获取的是数组的类型，得到的就是数组的长度*字节长度，如：int num[10]={0};  printf("%d",sizeof(num));		//这里打印的就是长度10*4字节，打印40
	'~' 按(二进制)位取反	如有一个数int num=0的话：~num就先把0的二进制位写出来
			由整型4字节*8 = 32bit，即00000000 00000000 00000000 00000000	取反 11111111 11111111 11111111 11111111，打印时，会输出它的原码结果为：-1
			规则如(原码符号位不变，其他位按位取反得到反码，反码+1得到补码)：
			11111111 11111111 11111111 11111111      --->     11111111 11111111 11111111 1111110      --->      10000000 00000000 00000000 00000001 
             这里是补码-->原码                                  	二进制位-1                                             按位取反(符号位不变，第一位为1表示为负数，后面的正常读取)
			(补码-1得到反码，反码按位取反得到原码)	
			只要是整数，内存中存储的都是二进制的补码
				正数--原码、反码、补码相同
				负数：
					原码		         --->			反码		      --->		        补码
					直接按照正负				原码的符号位不变				    反码+1
					写出的二进制序列		其他位取反得到
	'++ '/'--' 的使用规则和JS相同	
	'(类型)'是强制类型转换，括号内填入数据类型
		如：int num = 3.14	//这个时候程序虽然能够运行，但是会弹出一个警告，如果我们想消除这个警告的话，如下：
				int num = (double)3.14		//这里会启动强制类型转换，把double类型的数据类型转换成int
	'&'为取地址操作符，'*'为间接访问操作符，这两个后面再说		
- 关系操作符
	>  >=  <=  <  !=  ==
- 逻辑操作符
	&&       ||
	逻辑与   逻辑或
	'&&'两个数都为真才为真，反之为假
	'||'两个数有一个为真就是真，都为假才是假
- 条件操作符
	exp1 ? exp2 : exp3
	和JS意思相同，如：int max = 5>3 ? 5 : 3;	这里相当于执行了一个判断语句，先判断'?'前面的值是否为真，为真则执行':'左边的值，为假执行':'右边的值，这里max==5;
	和python则不同，python的条件操作符是 max = 5 if 5>3 else 3	先判断if语句右边的值，为真执行if左边的值，为假执行else后面的值，更像是缩写if语句
- 逗号表达式
	exp1 ,  exp2  , exp3 ,  ....expn
	总之用','隔开的就是逗号表达式
- 下标引用、函数调用、结构成员
	[]  ()  .  ->

11. 常用关键字
这里写几个其他语言中不常见的几个常见关键字
register		寄存器关键字，使用方法如：register int a = 10;	//建议把a这个变量存到寄存器中，注意这里是建议，具体放不放入寄存器，看编译器
sigend		有符号位整型，使用方法如：sigend int a = 10;		//这个效果和不输入sigend的整型效果相同，我们平时直接使用的int默认省略了sigend
unsigend	无符号位整型，使用方法如：unsigend int a = 10;		//这里的整型是无符号位的，意味着你不管输入正数还是负数，结果都是正数
struct		结构体关键字
typedef	类型重定义，使用方法如：typedef unsigend int u_int;		//此时我们把上面的那个无符号位整形unsigend重新定义名称为u_int，之后我们写代码用unsigend和u_int都是同一个意思了
union		联合体/共用体
static的三种用法：
	static		修饰局部变量，使用方法如：void test(){		//这是一个函数，原本这个函数中的局部变量num应该在出这个函数的时候生命周期就结束了
																	static int num = 1;	//而我们在变量前面加上static后这就是一个静态的局部变量，延长了他的生命周期
																	num++;
																	printf(num);		//这里打印出num以后，下次如果再调用本函数，本来num也会重新定义
															}									但是现在不会了，num++会再下次执行的时候以原来的num执行++
	static		修饰全局变量，和上面的局部变量不同，局部变量是延长了它的生命周期，用在全局变量中，会改变变量的作用域，让静态的全局变量只能在自己所在的源文件中使用
					如：static int num2 = 10;  //没假static的时候在其他源文件中，利用extern是可以访问这个变量的，使用static后就不行了
	static		修饰函数，改变了函数的链接属性，通俗来讲，就是改变的函数的作用域，和上面的全局变量一样，都会使其他源文件无法访问此文件中的函数
									正常函数是具有外部链接属性的，即可以在其他源文件用extern来访问的，使用static修饰以后，会变成内部链接属性，不接受其他文件的访问

12. define定义常量和宏
如何定义常量前面已经学过了，详见第5点
我们还可以用define定义宏--带参数，宏定义和函数定义有些相似
	- 函数求两个数最大值如：int max = Max(a,b);		//我们会在前面定义一个Max的函数来比较大小
	- 宏更加简单，如：max = Max(a,b);	//首先前面不用加数据类型int
		宏的定义：#define Max(x,y) (x>y?x:y)		//后面可以直接执行这个三目操作符的结果并赋值回来，这样操作会比函数更加简洁一些

13. 指针
- 有一种变量是用来存放地址的--指针变量
	语法：数据类型* 变量 = &变量;
	假设我们已经定义了num的值为10，定义指针如：
	int* num1 = &num;	//此时我们把num的地址取了出来，赋值给了变量num1，num1里面存的也就是num的地址
	printf("%p,%d",num1,num);		//此时我们打印num1是打印出一串十六进制数字，也就是num的地址，并且num还是等于10
	*num1 = 20；		//解引用操作符
	printf("%d",num);		//由于前面利用解引用找到num的地址，这时候做出的修改会直接应用到num上，所以这里会打印20
- 指针的大小
	指针在32位平台是4个字节，64位平台是8个字节
	
14. 结构体
- 我们前面学了很多类型，如int，double，char
	但是我们如果表达一个人，一本书，是不可能一个数据类型就表达的清的
		这时候我们需要一个复杂对象 --- 结构体，我们自己创造出来的一种类型
		语法：
			struct 结构体名称{
				数据类型 变量名;
				数据类型 变量名;
				....
			}
		实例：
			struct people {
				char name[20];		//这里定义的变量不能直接输入值噢，输入值的方法如下
				int age;
				char house[40];
			};
			
			int main() {
				struct people man = { "孙悟空",18,"花果山水帘洞"};		//这样就分别定义了结构体中三个变量的值
				printf("姓名：%s\n", man.name);	//打印的时候用'.'来进行访问
				printf("年龄：%d\n", man.age);
				man.age += 10;	//我们同样可以对结构体中的数值进行修改
				printf("十年后的年龄是：%d\n", man.age);
				printf("住址：%s\n", man.house);
				return 0;
			}
		- 上面虽然年龄的变量可以改，但是如果我们取修改姓名的值，就会报错，这是为什么呢，因为name是一个数组，而修改数组的值，我们要用strcpy()修改
			使用方法：
			strcpy(man.name,"猪八戒");		//strcpy全称叫string copy - 字符串拷贝 - 这是一个库函数，所以我们调用的时候要在前面加上#include <string.h>
			printf("姓名：%s\n",man.name);		//这时候我们再访问，名字就变了
		- 我们还可以用指针来访问结构体，如：
			struct people* p = &man;		//我们把man用取地址符取出地址赋值给p
			
			printf("姓名：%s\n", (*p).name);		//这时候我们可以用这种方法来访问结构体，但是未免有些麻烦，我们还可以简化些操作
			printf("姓名：%d\n", (*p).age);
			
			printf("姓名：%s\n", p->name);		//我们用'->'来访问，简单快捷
			
		- '.'和'->'两者的区别：
			'.'		结构体变量.成员
			'->'	结构体指针->成员
					








