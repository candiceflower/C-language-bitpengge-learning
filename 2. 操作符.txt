操作符详解
分类：
- 算数操作符
- 移位操作符
- 位操作符
- 赋值操作符
- 单目操作符
- 关系操作符
- 逻辑操作符
- 条件操作符
- 逗号表达式
- 下标引用、函数调用、结构成员

以下只举例比较生疏的
- 算数操作符
/除法：如果两个整数相除，得到的结果也是整数，即使你存入的是一个浮点型变量中，所以要小数除法，要在整数后面加小数点，如：5/2.0
%取模：取模操作符左右两边必须是整数

- 移位操作符
右移：
	1. 算数移位：右边丢弃，左边补原符号位。（程序一般采用此方法移位）
	2. 逻辑移位：右边丢弃，左边补0
	规律：向右移n位就相当于原数字除于2^n，向左移动n位就相当于乘2^n
	特殊情况（负数）：
	正整数数的原码反码补码都是一样的，负数由于内存中存储的是补码，所以我们要先计算出补码，补码右移一位，然后再由原码求补码，这里-1举例：
		10000000 00000000 00000000 00000001		原码
		11111111 11111111 11111111 11111110		反码
		11111111 11111111 11111111 11111111    补码
		111111111 11111111 11111111 11111111	右移 符号位不变
		10000000 00000000 00000000 00000000 	再取反码
		10000000 00000000 00000000 00000001		原码
		结果为-1
	规则：原码-->补码  符号位不变，按位取反得到反码，反码符号位不变再+1得到补码。
				补码-->原码 补码-1得到反码，反码符号位不变取反得到原码。
左移：
	左移更简单，左边丢弃右边补0，负数情况与上面相同，同样以-1举例：
	10000000 00000000 00000000 00000001		原码
	11111111 11111111 11111111 11111110		反码 
	11111111 11111111 11111111 11111111    补码
  111111111 11111111 11111111 11111110  	左移		
	10000000 00000000 00000000 00000001    反码	 	
	10000000 00000000 00000000 00000010		原码
	结果为-2
注意：对于移位操作符，不要移动负数位，这个是标准未定义的，如：num>>-1;  //这是不行的，同时num和移位的值必须是整数

位操作符
位操作符操作的都是二进制数
'&'与操作符：两个数的二进制位相与，都为1才为1
'|'或操作符：两个数的二进制位只要有一个为1就是1
'^'异或操作符：相异为1，相同为0

辅助操作符
即'='，这里仅讲连续赋值，如：x=a=10; //此时x和a的值都是10

单目操作符
'~'是按位取反的意思，取的是二进制位

逻辑操作符
这里仅展示例题：
	一、
	int main()
	{
		int i = 0, a = 0, b = 2, c = 3, d = 4;
		i = a++ && ++b && d++;		//这里因为a是0，然后和后面的操作符进行与运算后为假，后面的就不会再运算了，仅执行了a++
		printf("%d,%d,%d,%d\n", a, b, c, d);		//输出的结果是1，2，3，4
		return 0;
	}
	
	二、
	int main()
	{
		int i = 0, a = 1, b = 2, c = 3, d = 4;
		i = a++ || ++b || d++;			//这里的a是1，或运算只要有一个为真后面的就不用运算了，所以仅仅有a++进行了运算
		printf("%d,%d,%d,%d\n", a, b, c, d);		//输出的结果是2，2，3，4
		return 0;
	}
	
逗号表达式
	逗号表达式会从左往右计算，但是只取最后一个表达式的结果
	例题：
		int main()
		{
			int a = 1;
			int b = 2;
			int c = (a > b, a = b + 10, b = a + 1);		//a>b这里没有结果，然后执行a=b+10为12，最后执行b=a+1等于13，c也等于13
			printf("%d,%d,%d\n", a, b, c);		//结果为12，13，13
			return 0;
		}
		
点操作符   --   配合结构体使用，如：结构体.属性
struct Student {	使用struct创建结构体
	char name[20];
	int age;
	char gender[10];
};


int main()
{
	struct Student one = { "吕布",20,"男" };	//传入数据	
	printf("%s\n", one.name);		//用点操作符访问
	printf("%d\n", one.age);
	printf("%s\n", one.gender);
	return 0;
}

箭头操作符  '->'
同样以上面的结构体为例
int main()
{
	struct Student one = { "吕布",20,"男" };
	struct Student* p = &one;
	printf("%s\n", p->name);		//正常写应该(*p).name才能读取，但是这样太麻烦，我们可以用箭头快速读取
	printf("%d\n", p->age);
	printf("%s\n", p->gender);
	return 0;
}

隐式转换
	- 整型提升
	整型提升就是整型和字符型互相转换时的效果
	例子如下：
		int main()
		{
			char a = 3;	//3是整型，赋值给字符型要进行整型提升
				//	00000000 00000000 00000000 00000011
				// 给字符型变量a后会进行二进制截断，只有00000011
			char b = 127; //127同理
				//	00000000 00000000 00000000 01111111
				// 给字符型变量b后会进行二进制截断，只有01111111
			char c = a + b;	//a+b的时候又会进行整型提升
				//		00000000 00000000 00000000 00000011
				//	加	00000000 00000000 00000000 01111111
				//等于	00000000 00000000 00000000 10000010
				//	给字符型变量c后会进行二进制截断，只有10000010	
			printf("%d\n", c);
				// 打印输出的由于是整型，所以又要进行整型提升，补最前面的符号位，即
				//	11111111 11111111 11111111 10000010  这是补码，打印的是原码
				//	11111111 11111111 11111111 10000001	 反码
				//	10000000 00000000 00000000 01111110	 原码，转换为十进制就是-126
			return 0;
		}
	简单来说：
		char a,b,c;
		...
		a = b+c;
		b和c的值先被提升为普通整型，然后再执行加法运算
			加法运算完成后，结果将被截断，然后再存储与a中
			
	举例：		
	#include <stdio.h>

	int main()
	{
		char c = 1;
		printf("%u\n", sizeof(c));	//输出1
		printf("%u\n", sizeof(+c));		//输出4	这里的+c进行了运算，就会进行整型提升，而整型提升被sizeof读取到了就会变成int的长度
		printf("%u\n", sizeof(!c));	//输出1
	}

	算数操作符优先级
	操作符优先级可参考第5节的pdf
	注意：
	c + --c;
	类似于这种就是问题操作符，我们看操作符的优先级可以看出--的优先级更高，可能c究竟实在--执行前初始化呢，还是--执行后初始化呢，这里会有歧义
	我们在进行操作符运算的时候，一个让表达式只有唯一的一个操作路径，否则这个表达式可能会存在问题




































