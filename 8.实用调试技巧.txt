实用调试技巧
1. 栈区的默认使用
	- 先使用高地址处的空间
	- 再使用低地址处的空间
2. 数组随着下标的增长，地址是由低到高的变化
	所以如果我们越界访问数组时，又可能破坏其他变量的地址，要格外注意这个问题
	如：
		int main() {	//这就是一个越界访问的代码，程序在这里会进入死循环
			int i = 0;		
			int arr[10] = { 1,2,3,4,5,6,7,8,9,10 };
			for (i = 0; i <= 11; i++) {		//由于i创建在前面，所以会先使用高地址的空间
				printf("呵呵\n");
				arr[i] = 0;		//数组越界访问后，访问到i所在的空间，修改i的值为0，那么程序就会继续循环	
			}
			return 0;
		}
		
- strcpy方法
	此方法可以用于复制字符串，语法：strcpy(目的地，源头);   //即把源头的字符串复制到目的地，会把源头的每个字符，包括'\0'一起复制到目的地
	注意：目的地的长度一定要比源头更大，不然会越界访问

> assert()断言
	断言的作用是在程序合适的位置放置检查点，如果()内的值为true，程序正常执行，如果为false，程序会报错
		这样插入这个检查点后，可以及时的发现代码出现问题的位置，更好的维护程序
		需要加入头文件<assert.h>使用

> const使用方法
	1. 给普通变量的前面加上const，那么这个变量就是普通的常变量，是具有常属性的变量，不可以进行修改，但是也不能给数组的[]使用
	2. 给指针变量使用
		- 如果将const放在*的左边，如：const int* p = &num;	
			那么，意思是p取到地址的变量num中的值是不可以被指针修改的，如：*p = 20;   //原本可以改变num的值的，但是const修饰后不行
		- 如果将const放在*的右边，如：int* const p = &num;	
			那么，意思是这个p取到的地址是不可改变的，如：p = &a;   //原本p取的地址是可以改变的，但是现在不行，包括指针的加法减法运算也不行

> 错误的种类：
	1.  语法错误
		由于缺少分号，缺少大括号...基础语法内容导致的，好排查，双击报错警告即可
	2. 链接性错误
		如函数为声明，弹出的"无法解析外部符号...."，这类称为连接性错误，一般都是标识符没声明，或者声明了但是标识符拼写错误导致
			我们找到对应的标识符，查看是否链接错即可
	3. 运行时错误
		没有前面两个问题，只能借助调试，逐步定位错误
























	